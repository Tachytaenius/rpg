local registry = require("registry")
local assets = require("assets")
local constants = require("constants")
local generate = require("systems.generate")

local bw, bh, bd = constants.blockWidth, constants.blockHeight, constants.blockDepth
local cw, ch, cd = constants.chunkWidth, constants.chunkHeight, constants.chunkDepth

local terrainByIndex = registry.terrainByIndex

local vertexFormat = constants.vertexFormat

local updateMesh

local function get(t, k)
	if t then
		return t[k]
	end
end

local function set(t, k, v)
	if t then
		t[k] = v
	end
end

local function canDraw(thisBlock, neighbourBlock)
	thisBlock, neighbourBlock = terrainByIndex[thisBlock], terrainByIndex[neighbourBlock]
	return not thisBlock.invisible and (neighbourBlock == nil or neighbourBlock.invisible)
end

local function newChunk(x, y, z, chunks, bumpWorld, seed)
	local ret = {
		x = x, y = y, z = z,
		updateMesh = updateMesh -- This is a method
	}
	
	local pxNeighbour = get(get(get(chunks, x + 1), y), z)
	local nxNeighbour = get(get(get(chunks, x - 1), y), z)
	local pyNeighbour = get(get(get(chunks, x), y + 1), z)
	local nyNeighbour = get(get(get(chunks, x), y - 1), z)
	local pzNeighbour = get(get(get(chunks, x), y), z + 1)
	local nzNeighbour = get(get(get(chunks, x), y), z - 1)
	
	ret.pxNeighbour = pxNeighbour
	ret.nxNeighbour = nxNeighbour
	ret.pyNeighbour = pyNeighbour
	ret.nyNeighbour = nyNeighbour
	ret.pzNeighbour = pzNeighbour
	ret.nzNeighbour = nzNeighbour
	
	set(pxNeighbour, "nxNeighbour", ret)
	set(nxNeighbour, "pxNeighbour", ret)
	set(pyNeighbour, "nyNeighbour", ret)
	set(nyNeighbour, "pyNeighbour", ret)
	set(pzNeighbour, "nzNeighbour", ret)
	set(nzNeighbour, "pzNeighbour", ret)
	
	ret.terrain = generate(x, y, z, bumpWorld, seed)
	
	return ret
end

local addRect

-- Neighbouring chunks also influence face visibility
local function getBlock(chunk, x, y, z)
	local chunkToCheck = chunk
	 
	if x == -1 then
		chunkToCheck = chunk.nxNeighbour
	elseif x == cw then
		chunkToCheck = chunk.pxNeighbour
	elseif y == -1 then
		chunkToCheck = chunk.nyNeighbour
	elseif y == ch then
		chunkToCheck = chunk.pyNeighbour
	elseif z == -1 then
		chunkToCheck = chunk.nzNeighbour
	elseif z == cd then
		chunkToCheck = chunk.pzNeighbour
	end
	
	if chunkToCheck then
		x, y, z = x % cw, y % ch, z % cd
		return string.byte(chunkToCheck.terrain[x][z].columnString, y + 1)
	end
end

local bts = constants.blockTextureSize
local u1s, v1s, u2s, v2s = assets.terrain.u1s, assets.terrain.v1s, assets.terrain.u2s, assets.terrain.v2s
local chunkFaces = require("systems.chunkFaces") -- autogenerated code
function updateMesh(chunk)
	local chunkX, chunkY, chunkZ = chunk.x, chunk.y, chunk.z
	
	local verts, lenVerts = {}, 0
	
	for x = 0, cw - 1 do
		for y = 0, ch - 1 do
			for z = 0, cd - 1 do
				-- tb means "this block"
				local tb = string.byte(chunk.terrain[x][z].columnString, y + 1)
				local tbx, tby, tbz = chunkX * cw + x, chunkY * ch + y, chunkZ * cd + z
				if canDraw(tb) then
					local block = terrainByIndex[tb]
					local name = block.name
					local getTextureAtlasOffset = block.getTextureAtlasOffset
					local u1, v1, u2, v2 = u1s[name], v1s[name], u2s[name], v2s[name]
					
					local nzz = getBlock(chunk, x - 1, y, z)
					local pzz = getBlock(chunk, x + 1, y, z)
					local znz = getBlock(chunk, x, y - 1, z)
					local zpz = getBlock(chunk, x, y + 1, z)
					local zzn = getBlock(chunk, x, y, z - 1)
					local zzp = getBlock(chunk, x, y, z + 1)
					local nnz = getBlock(chunk, x - 1, y - 1, z)
					local pnz = getBlock(chunk, x + 1, y - 1, z)
					local npz = getBlock(chunk, x - 1, y + 1, z)
					local ppz = getBlock(chunk, x + 1, y + 1, z)
					local nzn = getBlock(chunk, x - 1, y, z - 1)
					local pzn = getBlock(chunk, x + 1, y, z - 1)
					local nzp = getBlock(chunk, x - 1, y, z + 1)
					local pzp = getBlock(chunk, x + 1, y, z + 1)
					
					-- for top, pos x = down, pos z = right
					
					if canDraw(tb, nxn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("nx", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "nyz", tbx * bw, tby * bh, tbz * bd, bh, bd, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
					if canDraw(tb, pxn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("px", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "pyz", (tbx + 1) * bw, tby * bh, tbz * bd, bh, bd, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
					if canDraw(tb, nzn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("nz", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "nxy", tbx * bw, tby * bh, tbz * bd, bw, bh, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
					if canDraw(tb, pzn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("pz", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "pxy", tbx * bw, tby * bh, (tbz + 1) * bd, bw, bh, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
					if canDraw(tb, nyn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("nz", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "nxz", tbx * bw, tby * bh, tbz * bd, bw, bd, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
					if canDraw(tb, pyn) then
						local textureIndex = getTextureAtlasOffset and getTextureAtlasOffset("pz", nzz, pzz, znz, zpz, zzn, zzp, nnz, pnz, npz, ppz, nzn, pzn, nzp, pzp) or 0
						local vOffset = bts * textureIndex
						addRect(verts, lenVerts, "pxz", tbx * bw, (tby + 1) * bh, tbz * bd, bw, bd, u1, v1 + vOffset, u2, v2 + vOffset)
						lenVerts = lenVerts + 6
					end
				end
			end
		end
	end
	
	if chunk.mesh then chunk.mesh:release() end
	if lenVerts == 0 then return end
	chunk.mesh = love.graphics.newMesh(vertexFormat, verts, "triangles")
end

function addRect(verts, lenVerts, side, x, y, z, a, b, u1, v1, u2, v2)
	local vv, vV, Vv, VV
	if side == "nyz" then
		vv = {x, y, z, u1, v2, -1, 0, 0}
		vV = {x, y, z + b, u2, v2, -1, 0, 0}
		Vv = {x, y + a, z, u1, v1, -1, 0, 0}
		VV = {x, y + a, z + b, u2, v1, -1, 0, 0}
	elseif side == "pyz" then
		vv = {x, y, z, u2, v2, 1, 0, 0}
		vV = {x, y + a, z, u2, v1, 1, 0, 0}
		Vv = {x, y, z + b, u1, v2, 1, 0, 0}
		VV = {x, y + a, z + b, u1, v1, 1, 0, 0}
	elseif side == "nxz" then
		vv = {x, y, z, u1, v2, 0, -1, 0}
		vV = {x + a, y, z, u2, v2, 0, -1, 0}
		Vv = {x, y, z + b, u1, v1, 0, -1, 0}
		VV = {x + a, y, z + b, u2, v1, 0, -1, 0}
	elseif side == "pxz" then
		vv = {x, y, z, u1, v1, 0, 1, 0}
		vV = {x, y, z + b, u1, v2, 0, 1, 0}
		Vv = {x + a, y, z, u2, v1, 0, 1, 0}
		VV = {x + a, y, z + b, u2, v2, 0, 1, 0}
	elseif side == "nxy" then
		vv = {x, y, z, u2, v2, 0, 0, -1}
		vV = {x, y + b, z, u2, v1, 0, 0, -1}
		Vv = {x + a, y, z, u1, v2, 0, 0, -1}
		VV = {x + a, y + b, z, u1, v1, 0, 0, -1}
	elseif side == "pxy" then
		vv = {x, y, z, u1, v2, 0, 0, 1}
		vV = {x + a, y, z, u2, v2, 0, 0, 1}
		Vv = {x, y + b, z, u1, v1, 0, 0, 1}
		VV = {x + a, y + b, z, u2, v1, 0, 0, 1}
	end
	
	verts[lenVerts + 1], verts[lenVerts + 2], verts[lenVerts + 3] = vv, vV, Vv
	verts[lenVerts + 4], verts[lenVerts + 5], verts[lenVerts + 6] = Vv, vV, VV
end

return newChunk
